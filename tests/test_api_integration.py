import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, AsyncMock

from app import app

@pytest.fixture
def client():
    """FastAPI test client."""
    return TestClient(app)

@pytest.fixture
def mock_workflow_result(sample_url):
    """Mock workflow result."""
    return {
        "summary": "This is a test summary of the website content generated by the mocked workflow.",
        "url": sample_url
    }

class TestHealthEndpoints:
    """Test health and info endpoints."""
    
    def test_health_check(self, client):
        """Test the health check endpoint."""
        response = client.get("/health")
        
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        assert "Website Summarization API" in data["message"]

    def test_root_endpoint(self, client):
        """Test the root endpoint."""
        response = client.get("/")
        
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        assert "endpoints" in data
        assert "POST /summarize" in data["endpoints"]

class TestSummarizeEndpoint:
    """Test the /summarize endpoint."""
    
    def test_summarize_success(self, client, mock_workflow_result, sample_url):
        """Test successful summarization via API endpoint."""
        
        with patch('app.summarization_workflow') as mock_workflow:
            mock_workflow.run = AsyncMock(return_value=mock_workflow_result)
            
            response = client.post(
                "/summarize",
                json={"url": sample_url}
            )
            
            assert response.status_code == 200
            data = response.json()
            assert data["summary"] == mock_workflow_result["summary"]
            assert data["url"] == mock_workflow_result["url"]
            # Note: Pydantic adds trailing slash to URLs
            mock_workflow.run.assert_called_once_with(url=sample_url + "/")

    def test_summarize_invalid_url_format(self, client):
        """Test API response for invalid URL format."""
        
        response = client.post(
            "/summarize",
            json={"url": "not-a-valid-url"}
        )
        
        assert response.status_code == 422  # Pydantic validation error
        data = response.json()
        assert "detail" in data

    def test_summarize_missing_url(self, client):
        """Test API response when URL is missing."""
        
        response = client.post(
            "/summarize",
            json={}
        )
        
        assert response.status_code == 422  # Pydantic validation error
        data = response.json()
        assert "detail" in data

    def test_summarize_workflow_exception(self, client, sample_url):
        """Test API error handling when workflow fails."""
        
        with patch('app.summarization_workflow') as mock_workflow:
            mock_workflow.run = AsyncMock(side_effect=Exception("Workflow failed"))
            
            response = client.post(
                "/summarize",
                json={"url": sample_url}
            )
            
            assert response.status_code == 500
            data = response.json()
            assert "error occurred while summarizing" in data["detail"]

    def test_summarize_http_exception_from_workflow(self, client, sample_url):
        """Test API handling of HTTPException from workflow."""
        
        from fastapi import HTTPException
        
        with patch('app.summarization_workflow') as mock_workflow:
            mock_workflow.run = AsyncMock(
                side_effect=HTTPException(status_code=400, detail="Failed to fetch content")
            )
            
            response = client.post(
                "/summarize",
                json={"url": sample_url}
            )
            
            assert response.status_code == 400
            data = response.json()
            assert "Failed to fetch content" in data["detail"]

    def test_summarize_options_request(self, client):
        """Test OPTIONS request for CORS handling."""
        
        response = client.options("/summarize")
        
        assert response.status_code == 200
        assert "Allow" in response.headers
        assert "POST, OPTIONS" in response.headers["Allow"]

    def test_upload_pdfs_options_request(self, client):
        """Test OPTIONS request for upload_pdfs endpoint CORS handling."""
        
        response = client.options("/upload_pdfs")
        
        assert response.status_code == 200
        assert "Allow" in response.headers
        assert "POST, OPTIONS" in response.headers["Allow"]

class TestAPIErrorHandling:
    """Test API-level error handling."""
    
    def test_nonexistent_endpoint(self, client):
        """Test 404 response for nonexistent endpoint."""
        
        response = client.get("/nonexistent")
        
        assert response.status_code == 404

    def test_invalid_json_payload(self, client):
        """Test handling of malformed JSON."""
        
        response = client.post(
            "/summarize",
            data="invalid json",
            headers={"Content-Type": "application/json"}
        )
        
        assert response.status_code == 422

    def test_wrong_http_method(self, client, sample_url):
        """Test using wrong HTTP method on summarize endpoint."""
        
        response = client.get("/summarize")
        
        assert response.status_code == 405  # Method Not Allowed

class TestAPIIntegrationFlow:
    """Test complete API integration flow."""
    
    def test_complete_api_flow_success(self, client, sample_url):
        """Test complete successful API flow from request to response."""
        
        # Mock the entire workflow chain
        mock_result = {
            "summary": "Complete integration test summary",
            "url": sample_url
        }
        
        with patch('app.summarization_workflow') as mock_workflow:
            mock_workflow.run = AsyncMock(return_value=mock_result)
            
            # Make request
            response = client.post(
                "/summarize",
                json={"url": sample_url}
            )
            
            # Verify response
            assert response.status_code == 200
            data = response.json()
            assert data["summary"] == mock_result["summary"]
            assert data["url"] == sample_url
            
            # Verify workflow was called correctly
            # Note: Pydantic adds trailing slash to URLs
            mock_workflow.run.assert_called_once_with(url=sample_url + "/")